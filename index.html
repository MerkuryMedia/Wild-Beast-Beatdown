<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wild Beast Beatdown</title>
  <style>
    :root {
      color-scheme: light;
      --bg: linear-gradient(160deg, #0ea5e9 0%, #22c55e 48%, #facc15 100%);
      --panel: rgba(255, 255, 255, 0.7);
      --panel-border: rgba(15, 118, 110, 0.28);
      --accent: #166534;
      --accent-strong: #f97316;
      --text-primary: #0f172a;
      --text-subtle: rgba(15, 23, 42, 0.7);
      --chip-bg: rgba(34, 197, 94, 0.18);
      --chip-border: rgba(22, 101, 52, 0.45);
      font-family: "Segoe UI", system-ui, -apple-system, BlinkMacSystemFont, "Roboto", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text-primary);
      display: flex;
      justify-content: center;
      padding: 1.5rem 1rem 4rem;
    }

    main {
      width: min(960px, 100%);
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    header.hud {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem 1.5rem;
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 18px;
      padding: 1rem 1.25rem;
      backdrop-filter: blur(6px);
    }

    .hud__item {
      font-size: 1rem;
    }

    .hud__value {
      font-weight: 600;
      color: var(--accent);
    }

    #statusText {
      font-style: italic;
      color: var(--text-subtle);
    }

    .arena {
      position: relative;
      background: radial-gradient(circle at 50% 25%, rgba(187, 247, 208, 0.95), rgba(74, 222, 128, 0.92), rgba(21, 128, 61, 0.95));
      border: 1px solid rgba(22, 101, 52, 0.45);
      border-radius: 26px;
      padding: clamp(1.5rem, 5vw, 2.25rem);
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 0.75rem;
      align-items: center;
      overflow: hidden;
      box-shadow: 0 24px 46px rgba(14, 116, 144, 0.35);
    }

    .arena::before {
      content: "";
      position: absolute;
      inset: 10% 15%;
      border: 2px dashed rgba(250, 204, 21, 0.45);
      border-radius: 20px;
      pointer-events: none;
    }

    .arena::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.18), transparent 58%),
        radial-gradient(circle at 80% 70%, rgba(254, 249, 195, 0.15), transparent 60%);
      pointer-events: none;
      mix-blend-mode: screen;
    }

    .side {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.75rem;
      text-align: center;
      z-index: 1;
    }

    .versus {
      font-size: clamp(1.25rem, 5vw, 2.2rem);
      font-weight: 700;
      letter-spacing: 0.1em;
      color: rgba(15, 23, 42, 0.65);
      text-shadow: 0 0 14px rgba(34, 197, 94, 0.35);
    }

    .sprite-shell {
      position: relative;
      width: clamp(160px, 36vw, 260px);
      aspect-ratio: 1 / 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .sprite-stance {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      --tx: 0px;
      --ty: 0px;
      --rot: 0deg;
      --scale: 1;
      --mirror: 1;
      transform: translateX(var(--tx)) translateY(var(--ty)) rotate(var(--rot)) scale(var(--scale)) scaleX(var(--mirror));
      transition: transform 250ms cubic-bezier(0.22, 0.94, 0.38, 1);
    }

    .sprite-stance.mirror {
      --mirror: -1;
    }

    .sprite-stance.lunge-left {
      --tx: 30px;
      --scale: 1.05;
      --rot: -2deg;
    }

    .sprite-stance.lunge-right {
      --tx: -30px;
      --scale: 1.05;
      --rot: 2deg;
    }

    .sprite-stance.ko-left {
      --rot: 6deg;
      --ty: 26px;
      --scale: 0.94;
    }

    .sprite-stance.ko-right {
      --rot: -6deg;
      --ty: 26px;
      --scale: 0.94;
    }

    img.sprite {
      width: 100%;
      height: auto;
      display: block;
      image-rendering: crisp-edges;
      user-select: none;
      pointer-events: none;
      filter: drop-shadow(0 24px 38px rgba(14, 116, 144, 0.45));
      animation: idle-bob 2.6s ease-in-out infinite;
      transition: opacity 280ms ease;
    }

    .sprite.ko {
      opacity: 0.2;
      filter: drop-shadow(0 10px 15px rgba(0, 0, 0, 0.4));
    }

    @keyframes idle-bob {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(10px); }
    }

    .sprite-shell.hit-shake {
      animation: hit-shake 280ms ease;
    }

    @keyframes hit-shake {
      0% { transform: translateX(0); }
      20% { transform: translateX(-12px); }
      40% { transform: translateX(10px); }
      60% { transform: translateX(-8px); }
      80% { transform: translateX(6px); }
      100% { transform: translateX(0); }
    }

    .sprite.hit-flash {
      animation: hit-flash 200ms ease;
    }

    @keyframes hit-flash {
      0% { filter: brightness(1.2) drop-shadow(0 30px 45px rgba(0,0,0,0.55)); }
      100% { filter: brightness(1) drop-shadow(0 30px 45px rgba(0,0,0,0.55)); }
    }

    .sprite-fallback {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.88);
      border: 1px dashed rgba(22, 101, 52, 0.55);
      border-radius: 22px;
      font-size: 0.95rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-primary);
      text-align: center;
      white-space: pre-line;
    }

    .info h2 {
      margin: 0;
      font-size: clamp(1.1rem, 3.5vw, 1.6rem);
    }

    .stat-chips {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.4rem;
      font-size: 0.75rem;
    }

    .stat-chip {
      background: var(--chip-bg);
      border: 1px solid var(--chip-border);
      border-radius: 999px;
      padding: 0.25rem 0.55rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-primary);
    }

    .controls {
      background: var(--panel);
      border: 1px solid var(--panel-border);
      border-radius: 18px;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1.1rem;
      backdrop-filter: blur(8px);
    }

    .controls h3 {
      margin: 0;
      font-size: 1rem;
      color: var(--accent);
    }

    .pick-options {
      display: grid;
      gap: 0.75rem;
    }

    .pick-card {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      padding: 0.8rem 1rem;
      background: rgba(255, 255, 255, 0.45);
      border: 1px solid rgba(22, 101, 52, 0.25);
      border-radius: 14px;
      cursor: pointer;
      transition: border-color 140ms ease, box-shadow 140ms ease;
    }

    .pick-card:hover,
    .pick-card:focus-within {
      border-color: rgba(250, 204, 21, 0.7);
      box-shadow: 0 0 0 3px rgba(250, 204, 21, 0.15);
    }

    .pick-card.selected {
      border-color: rgba(249, 115, 22, 0.9);
      box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.22);
      background: rgba(249, 115, 22, 0.2);
    }

    .pick-card span {
      font-weight: 600;
    }

    .pick-card small {
      color: var(--text-subtle);
      font-size: 0.75rem;
    }

    .pick-card input[type="radio"] {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }

    .bet-buttons {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
      gap: 0.65rem;
    }

    .bet-buttons button {
      padding: 0.75rem 0.5rem;
      font-size: 1rem;
      font-weight: 600;
      border-radius: 12px;
      border: 1px solid rgba(250, 204, 21, 0.65);
      background: rgba(250, 204, 21, 0.15);
      color: var(--text-primary);
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
    }

    .bet-buttons button:hover:not(:disabled),
    .bet-buttons button:focus-visible:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(250, 204, 21, 0.25);
      background: rgba(250, 204, 21, 0.3);
    }

    .bet-buttons button:disabled {
      cursor: not-allowed;
      opacity: 0.45;
      box-shadow: none;
    }

    .note {
      font-size: 0.8rem;
      color: var(--text-subtle);
    }

    .status-note {
      font-weight: 600;
      color: rgba(248, 113, 113, 0.9);
    }

    .toggle-row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.6rem;
    }

    .toggle-row label {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .toggle-row input[type="checkbox"] {
      width: 40px;
      height: 22px;
      appearance: none;
      background: rgba(148, 163, 184, 0.4);
      border-radius: 999px;
      position: relative;
      transition: background 140ms ease;
    }

    .toggle-row input[type="checkbox"]::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 3px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #fff;
      transform: translateX(0);
      transition: transform 140ms ease;
    }

    .toggle-row input[type="checkbox"]:checked {
      background: rgba(249, 115, 22, 0.8);
    }

    .toggle-row input[type="checkbox"]:checked::after {
      transform: translateX(18px);
    }

    .toggle-row button,
    #resetBalanceBtn,
    #addTokensBtn {
      background: rgba(37, 99, 235, 0.25);
      color: var(--text-primary);
      border: 1px solid rgba(37, 99, 235, 0.55);
      border-radius: 10px;
      padding: 0.45rem 0.75rem;
      cursor: pointer;
      font-size: 0.85rem;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }

    .toggle-row button:hover,
    #resetBalanceBtn:hover,
    #addTokensBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(37, 99, 235, 0.2);
    }

    #resetBalanceBtn,
    #addTokensBtn {
      align-self: flex-start;
    }

    .dev-panel {
      background: rgba(255, 255, 255, 0.78);
      border-radius: 12px;
      border: 1px solid rgba(15, 118, 110, 0.28);
      padding: 0.8rem 1rem;
      margin-top: 0.5rem;
      font-size: 0.8rem;
    }

    .dev-grid {
      display: grid;
      gap: 0.35rem;
    }

    .dev-grid button {
      justify-self: start;
      padding: 0.3rem 0.6rem;
      font-size: 0.75rem;
      border-radius: 8px;
      border: 1px solid rgba(59, 130, 246, 0.5);
      background: rgba(59, 130, 246, 0.18);
      color: var(--text-primary);
      cursor: pointer;
    }

    .result-banner {
      position: absolute;
      bottom: 1.2rem;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(22, 101, 52, 0.92);
      border: 1px solid rgba(250, 204, 21, 0.55);
      border-radius: 999px;
      padding: 0.6rem 1.4rem;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.2rem;
      min-width: 210px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 200ms ease;
      color: #f8fafc;
    }

    .result-banner.visible {
      opacity: 1;
    }

    .result-banner span:nth-child(2) {
      font-size: 0.85rem;
      color: rgba(255, 255, 255, 0.75);
      text-transform: uppercase;
    }

    .spark {
      position: absolute;
      width: 90px;
      height: 90px;
      pointer-events: none;
      background: radial-gradient(circle at center, rgba(255, 249, 196, 0.9) 0%, rgba(250, 204, 21, 0.55) 40%, rgba(249, 115, 22, 0) 70%);
      opacity: 0;
      transform: scale(0.4);
      animation: spark-burst 200ms ease-out forwards;
    }

    .spark.left {
      left: 45%;
      top: 45%;
    }

    .spark.right {
      right: 45%;
      top: 45%;
    }

    @keyframes spark-burst {
      0% { opacity: 0; transform: scale(0.3); }
      30% { opacity: 1; transform: scale(1); }
      100% { opacity: 0; transform: scale(1.6); }
    }

    .loading-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      background: rgba(9, 10, 15, 0.94);
      color: #f8fafc;
      font-size: 1.1rem;
      z-index: 20;
    }

    .loading-overlay .bar {
      width: clamp(200px, 50vw, 320px);
      height: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 999px;
      overflow: hidden;
    }

    .loading-overlay .bar span {
      display: block;
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, rgba(250, 204, 21, 0.9), rgba(249, 115, 22, 0.9));
      border-radius: 999px;
      transition: width 180ms ease;
    }

    details {
      color: var(--text-subtle);
    }

    details summary {
      cursor: pointer;
      font-weight: 600;
      color: rgba(22, 101, 52, 0.85);
    }

    details[open] summary {
      color: rgba(37, 99, 235, 0.85);
    }

    @media (max-width: 860px) {
      .arena {
        grid-template-columns: 1fr;
        padding-inline: clamp(1.25rem, 8vw, 2rem);
      }

      .versus {
        order: -1;
      }

      .side {
        flex-direction: column;
      }

      .sprite-shell {
        width: clamp(160px, 60vw, 260px);
      }
    }

    @media (max-width: 600px) {
      body {
        padding-bottom: 2rem;
      }

      header.hud {
        flex-direction: column;
        align-items: flex-start;
      }

      .pick-card {
        flex-direction: column;
        align-items: flex-start;
      }

      .result-banner {
        bottom: 0.6rem;
      }
    }

    body.reduce-motion img.sprite {
      animation: none;
    }

    body.reduce-motion .sprite-shell.hit-shake {
      animation: none;
    }

    body.reduce-motion .sprite.hit-flash {
      animation: none;
    }

    body.reduce-motion .spark {
      display: none;
    }

    body.reduce-motion .sprite-stance.lunge-left,
    body.reduce-motion .sprite-stance.lunge-right {
      --tx: 12px;
      --scale: 1.02;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="loading-overlay" id="loadingOverlay" role="alert" aria-live="polite">
    <div>Loading Wild Beast Beatdown…</div>
    <div class="bar"><span id="loadingBar"></span></div>
    <div id="loadingText">Loading… (0/24)</div>
  </div>
  <main id="game" class="hidden" aria-live="polite">
    <header class="hud">
      <div class="hud__item">Balance: <span class="hud__value" id="balanceValue">0</span> tokens</div>
      <div class="hud__item">Round <span class="hud__value" id="roundValue">1</span></div>
      <div class="hud__item" id="statusText">Loading…</div>
    </header>

    <section class="arena" id="arena">
      <div class="side" data-side="left">
        <div class="sprite-shell" id="leftShell">
          <div class="sprite-stance" id="leftStance">
            <img id="leftSprite" class="sprite" alt="Left fighter" draggable="false">
          </div>
          <div id="leftFallback" class="sprite-fallback" hidden>Missing art</div>
        </div>
        <div class="info">
          <h2 id="leftName">---</h2>
          <div class="stat-chips" id="leftStats"></div>
        </div>
      </div>
      <div class="versus" aria-hidden="true">VS</div>
      <div class="side" data-side="right">
        <div class="sprite-shell" id="rightShell">
          <div class="sprite-stance mirror" id="rightStance">
            <img id="rightSprite" class="sprite" alt="Right fighter" draggable="false">
          </div>
          <div id="rightFallback" class="sprite-fallback" hidden>Missing art</div>
        </div>
        <div class="info">
          <h2 id="rightName">---</h2>
          <div class="stat-chips" id="rightStats"></div>
        </div>
      </div>
      <div class="result-banner" id="resultBanner" aria-live="assertive">
        <span id="resultWinner">Winner: TBD</span>
        <span id="resultSummary">Awaiting battle…</span>
      </div>
    </section>

    <section class="controls" aria-label="Controls">
      <div>
        <h3>Pick your contender</h3>
        <div class="pick-options">
          <label class="pick-card" id="pickCardLeft">
            <div>
              <span id="pickLeftName">Left fighter</span>
              <div><small>Tap or press space to choose.</small></div>
            </div>
            <input type="radio" name="fighter" id="pickLeft" value="left">
          </label>
          <label class="pick-card" id="pickCardRight">
            <div>
              <span id="pickRightName">Right fighter</span>
              <div><small>Tap or press space to choose.</small></div>
            </div>
            <input type="radio" name="fighter" id="pickRight" value="right">
          </label>
        </div>
      </div>

      <div>
        <h3>Bet amount</h3>
        <div class="bet-buttons" id="betButtons">
          <button type="button" data-bet="2">2</button>
          <button type="button" data-bet="5">5</button>
          <button type="button" data-bet="10">10</button>
          <button type="button" data-bet="15">15</button>
        </div>
        <div class="note">50/50 coin toss—stats are cosmetic.</div>
        <div class="note status-note hidden" id="balanceNote">Out of tokens! Reset to 100 to keep playing.</div>
      </div>

      <div class="toggle-row">
        <label for="skipToggle">
          <input type="checkbox" id="skipToggle">
          Skip fight animation (fast resolve)
        </label>
        <button type="button" id="resetBalanceBtn">Reset balance to 100</button>
      </div>

      <details>
        <summary>Dev panel</summary>
        <div class="dev-panel">
          <div class="dev-grid">
            <div>Last RNG (hex): <span id="devRand">--</span></div>
            <div>Last winner ID: <span id="devWinner">--</span></div>
            <button type="button" id="addTokensBtn">Add +10 tokens</button>
            <div id="devRngToggleRow" class="toggle-row hidden">
              <label for="devRngToggle">
                <input type="checkbox" id="devRngToggle">
                Use deterministic dev RNG
              </label>
            </div>
          </div>
        </div>
      </details>
    </section>
  </main>

  <script>
  (() => {
    const ANIMALS = [
      { id: "orange-house-cat", name: "Orange House Cat", speed: 100, power: 20, ferocity: 100 },
      { id: "armadillo", name: "Armadillo", speed: 60, power: 80, ferocity: 80 },
      { id: "grizzly-bear", name: "Grizzly Bear", speed: 40, power: 100, ferocity: 80 },
      { id: "honey-badger", name: "Honey Badger", speed: 80, power: 40, ferocity: 100 },
      { id: "moose", name: "Moose", speed: 40, power: 100, ferocity: 80 },
      { id: "triceratops", name: "Triceratops", speed: 30, power: 100, ferocity: 90 },
      { id: "orangutan", name: "Orangutan", speed: 60, power: 80, ferocity: 80 },
      { id: "dodo-bird", name: "Dodo Bird", speed: 80, power: 20, ferocity: 100 }
    ];

    const POSES = ["idle", "attack", "death"];
    const TOTAL_ASSETS = ANIMALS.length * POSES.length;

    const assetCache = Object.create(null);
    const failedAssets = new Set();

    const state = {
      balance: 100,
      round: 1,
      left: null,
      right: null,
      pickSide: null,
      bet: null,
      locked: true,
      lastRandHex: "--",
      lastWinnerId: "--",
      skip: false,
      reduceMotion: false,
      devRngEnabled: false
    };

    const allowDevSeed = new URLSearchParams(location.search).get("seed") === "dev";
    let devSeed = 0x12345678;

    const elements = {
      loadingOverlay: document.getElementById("loadingOverlay"),
      loadingText: document.getElementById("loadingText"),
      loadingBar: document.getElementById("loadingBar"),
      game: document.getElementById("game"),
      balanceValue: document.getElementById("balanceValue"),
      roundValue: document.getElementById("roundValue"),
      statusText: document.getElementById("statusText"),
      leftName: document.getElementById("leftName"),
      rightName: document.getElementById("rightName"),
      leftStats: document.getElementById("leftStats"),
      rightStats: document.getElementById("rightStats"),
      leftSprite: document.getElementById("leftSprite"),
      rightSprite: document.getElementById("rightSprite"),
      leftFallback: document.getElementById("leftFallback"),
      rightFallback: document.getElementById("rightFallback"),
      leftStance: document.getElementById("leftStance"),
      rightStance: document.getElementById("rightStance"),
      leftShell: document.getElementById("leftShell"),
      rightShell: document.getElementById("rightShell"),
      pickLeft: document.getElementById("pickLeft"),
      pickRight: document.getElementById("pickRight"),
      pickCardLeft: document.getElementById("pickCardLeft"),
      pickCardRight: document.getElementById("pickCardRight"),
      pickLeftName: document.getElementById("pickLeftName"),
      pickRightName: document.getElementById("pickRightName"),
      betButtons: Array.from(document.querySelectorAll("#betButtons button")),
      balanceNote: document.getElementById("balanceNote"),
      skipToggle: document.getElementById("skipToggle"),
      resetBalanceBtn: document.getElementById("resetBalanceBtn"),
      addTokensBtn: document.getElementById("addTokensBtn"),
      devRand: document.getElementById("devRand"),
      devWinner: document.getElementById("devWinner"),
      devRngToggleRow: document.getElementById("devRngToggleRow"),
      devRngToggle: document.getElementById("devRngToggle"),
      arena: document.getElementById("arena"),
      resultBanner: document.getElementById("resultBanner"),
      resultWinner: document.getElementById("resultWinner"),
      resultSummary: document.getElementById("resultSummary")
    };

    const statKeys = [
      { key: "speed", label: "Speed" },
      { key: "power", label: "Power" },
      { key: "ferocity", label: "Ferocity" }
    ];

    const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

    function init() {
      attachEventListeners();
      setupMotionPreference();
      restoreBalance();
      updateDevPanel();
      preloadAssets().then(() => {
        elements.loadingOverlay.classList.add("hidden");
        state.locked = true;
        elements.game.classList.remove("hidden");
        setStatus("Pairing fighters…");
        updateRoundDisplay();
        updateBalanceDisplay();
        state.round = 1;
        newPairing();
      });
    }

    function attachEventListeners() {
      elements.pickLeft.addEventListener("change", () => handlePickChange("left"));
      elements.pickRight.addEventListener("change", () => handlePickChange("right"));

      elements.betButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          const amount = Number(btn.dataset.bet || 0);
          attemptBet(amount);
        });
      });

      elements.skipToggle.addEventListener("change", () => {
        state.skip = elements.skipToggle.checked;
      });

      elements.resetBalanceBtn.addEventListener("click", () => {
        setBalance(100);
        flashStatus("Balance reset to 100 tokens.");
      });

      elements.addTokensBtn.addEventListener("click", () => {
        setBalance(state.balance + 10);
        flashStatus("Added 10 tokens.");
      });

      if (allowDevSeed) {
        elements.devRngToggleRow.classList.remove("hidden");
        elements.devRngToggle.addEventListener("change", () => {
          state.devRngEnabled = elements.devRngToggle.checked;
          flashStatus(state.devRngEnabled ? "Dev RNG enabled." : "Dev RNG disabled.");
        });
      }
    }

    function setupMotionPreference() {
      const media = window.matchMedia("(prefers-reduced-motion: reduce)");
      const apply = () => {
        state.reduceMotion = media.matches;
        document.body.classList.toggle("reduce-motion", state.reduceMotion);
      };
      media.addEventListener("change", apply);
      apply();
    }

    function restoreBalance() {
      try {
        const saved = localStorage.getItem("wbb_balance");
        if (saved !== null && !Number.isNaN(Number(saved))) {
          state.balance = Number(saved);
        } else {
          setBalance(100);
        }
      } catch (err) {
        state.balance = 100;
      }
      updateBalanceDisplay();
    }

    function setBalance(value) {
      state.balance = Math.max(0, Math.round(value));
      try {
        localStorage.setItem("wbb_balance", String(state.balance));
      } catch (err) {
        /* localStorage might be unavailable; ignore */
      }
      updateBalanceDisplay();
    }

    function updateBalanceDisplay() {
      elements.balanceValue.textContent = state.balance;
      const broke = state.balance < 2;
      elements.balanceNote.classList.toggle("hidden", !broke);
      updateBetButtons();
    }

    function updateRoundDisplay() {
      elements.roundValue.textContent = state.round;
    }

    function setStatus(text) {
      elements.statusText.textContent = text;
    }

    function flashStatus(text) {
      setStatus(text);
      setTimeout(() => {
        if (!state.locked) {
          setStatus("Select your fighter.");
        }
      }, 1500);
    }

    function preloadAssets() {
      let completed = 0;
      elements.loadingBar.style.width = "0%";
      return new Promise((resolve) => {
        ANIMALS.forEach((animal) => {
          assetCache[animal.id] = {};
          POSES.forEach((pose) => {
            const img = new Image();
            assetCache[animal.id][pose] = img;
            img.onload = () => {
              completed += 1;
              updateLoadingProgress(completed);
              if (completed === TOTAL_ASSETS) resolve();
            };
            img.onerror = () => {
              failedAssets.add(`${animal.id}_${pose}`);
              completed += 1;
              updateLoadingProgress(completed);
              if (completed === TOTAL_ASSETS) resolve();
            };
            img.src = `./assets/${animal.id}_${pose}.png`;
          });
        });
      });
    }

    function updateLoadingProgress(done) {
      elements.loadingText.textContent = `Loading… (${done}/${TOTAL_ASSETS})`;
      const pct = Math.round((done / TOTAL_ASSETS) * 100);
      elements.loadingBar.style.width = `${pct}%`;
    }

    function handlePickChange(side) {
      if (state.locked) return;
      state.pickSide = side;
      state.pickCardLeft.classList.toggle("selected", side === "left");
      state.pickCardRight.classList.toggle("selected", side === "right");
      updateBetButtons();
      setStatus("Place your bet.");
    }

    function updateBetButtons() {
      const disabledGlobally = state.locked || !state.pickSide || state.balance < 2;
      elements.betButtons.forEach((button) => {
        const bet = Number(button.dataset.bet || 0);
        const disabled = disabledGlobally || state.balance < bet;
        button.disabled = disabled;
        button.setAttribute("aria-disabled", String(disabled));
      });
    }

    function attemptBet(amount) {
      if (state.locked) return;
      if (!state.pickSide) {
        flashStatus("Pick a fighter first.");
        return;
      }
      if (state.balance < amount) {
        flashStatus("Not enough tokens.");
        return;
      }
      lockBetAndDecide(amount);
    }

    function lockBetAndDecide(amount) {
      state.locked = true;
      updateBetButtons();
      elements.pickLeft.disabled = true;
      elements.pickRight.disabled = true;
      elements.skipToggle.disabled = true;
      elements.resetBalanceBtn.disabled = true;
      elements.addTokensBtn.disabled = true;
      if (elements.devRngToggle) {
        elements.devRngToggle.disabled = true;
      }
      setStatus("Animating…");

      setBalance(state.balance - amount);
      state.bet = amount;

      const { bit, raw } = fairBit();
      const winnerSide = bit === 0 ? "left" : "right";
      const loserSide = winnerSide === "left" ? "right" : "left";
      state.lastRandHex = `0x${raw.toString(16).padStart(8, "0")}`;
      state.lastWinnerId = state[winnerSide]?.id || "--";
      updateDevPanel();

      playFightSequence(winnerSide, loserSide).then(() => {
        settleAndShowResult(winnerSide, loserSide);
      });
    }

    function fairBit() {
      if (allowDevSeed && state.devRngEnabled) {
        devSeed = (devSeed * 1664525 + 1013904223) >>> 0;
        return { bit: devSeed & 1, raw: devSeed >>> 0 };
      }
      const u32 = new Uint32Array(1);
      crypto.getRandomValues(u32);
      return { bit: u32[0] & 1, raw: u32[0] >>> 0 };
    }

    async function playFightSequence(winnerSide, loserSide) {
      const totalAttacks = state.skip ? 3 : 4;
      const attackDuration = state.skip ? 110 : 260;
      const pauseDuration = state.skip ? 140 : 620;
      let attacker = "left";
      for (let i = 0; i < totalAttacks; i += 1) {
        const defender = attacker === "left" ? "right" : "left";
        await performAttack(attacker, defender, attackDuration, pauseDuration);
        attacker = defender;
      }
      if (!state.skip) {
        await wait(1200);
      }
    }

    async function performAttack(attackerSide, defenderSide, attackDuration, pauseDuration) {
      const attacker = getSideElements(attackerSide);
      const defender = getSideElements(defenderSide);
      setPose(attackerSide, "attack");
      toggleLunge(attackerSide, true);
      if (!state.reduceMotion) {
        defender.shell.classList.add("hit-shake");
        defender.sprite.classList.add("hit-flash");
        spawnSpark(attackerSide);
      }
      await wait(attackDuration);
      setPose(attackerSide, "idle");
      toggleLunge(attackerSide, false);
      defender.shell.classList.remove("hit-shake");
      defender.sprite.classList.remove("hit-flash");
      await wait(pauseDuration);
    }

    function spawnSpark(side) {
      const spark = document.createElement("div");
      spark.className = `spark ${side}`;
      elements.arena.appendChild(spark);
      spark.addEventListener("animationend", () => {
        spark.remove();
      });
    }

    function toggleLunge(side, active) {
      const stance = side === "left" ? elements.leftStance : elements.rightStance;
      stance.classList.toggle(side === "left" ? "lunge-left" : "lunge-right", active);
    }

    function setPose(side, pose) {
      const { animal, sprite, fallback } = getSideElements(side);
      if (!animal) return;
const key = `${animal.id}_${pose}`;

// Always attempt to load the image now, even if the preloader once failed.
sprite.classList.remove("hidden");
fallback.hidden = true;

const url = `./assets/${animal.id}_${pose}.png`;
sprite.alt = `${animal.name} ${pose}`;

// If this specific <img> fails at runtime, show fallback for this attempt only.
sprite.onerror = () => {
  sprite.onerror = null; // avoid loops
  sprite.classList.add("hidden");
  fallback.hidden = false;
  fallback.textContent = `${animal.name}\n(${pose})`;
};

// Prefer preloaded src if present; else use the URL directly.
const cached = assetCache[animal.id]?.[pose];
sprite.src = (cached && cached.src) ? cached.src : url;

// KO styling
if (pose === "death") {
  sprite.classList.add("ko");
} else {
  sprite.classList.remove("ko");
}
const stance = side === "left" ? elements.leftStance : elements.rightStance;
stance.classList.toggle("ko-left", pose === "death" && side === "left");
stance.classList.toggle("ko-right", pose === "death" && side === "right");

    }

    function getSideElements(side) {
      if (side === "left") {
        return {
          animal: state.left,
          sprite: elements.leftSprite,
          fallback: elements.leftFallback,
          stance: elements.leftStance,
          shell: elements.leftShell
        };
      }
      return {
        animal: state.right,
        sprite: elements.rightSprite,
        fallback: elements.rightFallback,
        stance: elements.rightStance,
        shell: elements.rightShell
      };
    }

    async function settleAndShowResult(winnerSide, loserSide) {
      setStatus("Settling…");
      setPose(loserSide, "death");
      setPose(winnerSide, "idle");

      const winner = state[winnerSide];
      const loser = state[loserSide];
      const playerPickedWinner = state.pickSide === winnerSide;
      const stake = state.bet || 0;

      if (playerPickedWinner) {
        setBalance(state.balance + stake * 2);
      }

      elements.resultWinner.textContent = `Winner: ${winner?.name || "???"}`;
      elements.resultSummary.textContent = playerPickedWinner ? `YOU WIN +${stake}` : `You lose -${stake}`;
      elements.resultBanner.classList.add("visible");

      updateDevPanel();

      await wait(1000);
      resetForNextRound();
    }

    function updateDevPanel() {
      elements.devRand.textContent = state.lastRandHex;
      elements.devWinner.textContent = state.lastWinnerId;
    }

    function resetForNextRound() {
      elements.resultBanner.classList.remove("visible");
      state.round += 1;
      updateRoundDisplay();
      setStatus("Pairing fighters…");
      setTimeout(() => {
        newPairing();
      }, 1000);
    }

    function newPairing() {
      state.locked = true;
      updateBetButtons();
      elements.pickLeft.checked = false;
      elements.pickRight.checked = false;
      elements.pickLeft.disabled = true;
      elements.pickRight.disabled = true;
      elements.skipToggle.disabled = true;
      elements.resetBalanceBtn.disabled = true;
      elements.addTokensBtn.disabled = true;
      if (elements.devRngToggle) {
        elements.devRngToggle.disabled = true;
      }

      state.pickSide = null;
      state.bet = null;

      const [left, right] = rollDistinctPair();
      state.left = left;
      state.right = right;

      renderSide("left", left);
      renderSide("right", right);
      setPose("left", "idle");
      setPose("right", "idle");

      elements.pickCardLeft.classList.remove("selected");
      elements.pickCardRight.classList.remove("selected");

      setTimeout(() => {
        state.locked = false;
        setStatus("Select your fighter.");
        elements.pickLeft.disabled = false;
        elements.pickRight.disabled = false;
        elements.skipToggle.disabled = false;
        elements.resetBalanceBtn.disabled = false;
        elements.addTokensBtn.disabled = false;
        if (elements.devRngToggle) {
          elements.devRngToggle.disabled = false;
        }
        updateBetButtons();
      }, 1000);
    }

    function renderSide(side, animal) {
      const nameEl = side === "left" ? elements.leftName : elements.rightName;
      const statsEl = side === "left" ? elements.leftStats : elements.rightStats;
      const pickNameEl = side === "left" ? elements.pickLeftName : elements.pickRightName;
      nameEl.textContent = animal.name;
      pickNameEl.textContent = animal.name;
      statsEl.innerHTML = "";
      statKeys.forEach(({ key, label }) => {
        const chip = document.createElement("span");
        chip.className = "stat-chip";
        chip.textContent = `${label}: ${animal[key]}`;
        statsEl.appendChild(chip);
      });
    }

    function rollDistinctPair() {
      const firstIndex = secureRandomIndex(ANIMALS.length);
      let secondIndex = secureRandomIndex(ANIMALS.length - 1);
      if (secondIndex >= firstIndex) {
        secondIndex += 1;
      }
      return [ANIMALS[firstIndex], ANIMALS[secondIndex]];
    }

    function secureRandomIndex(max) {
      if (max <= 0) return 0;
      const maxUint = 0xFFFFFFFF;
      const limit = maxUint - (maxUint % max);
      const buffer = new Uint32Array(1);
      let value;
      do {
        crypto.getRandomValues(buffer);
        value = buffer[0];
      } while (value >= limit);
      return value % max;
    }

    document.addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden") {
        // Pause idle audio/animations if needed in future.
      }
    });

    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", init);
    } else {
      init();
    }
  })();
  </script>
</body>
</html>
